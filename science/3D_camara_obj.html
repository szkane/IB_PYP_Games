<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Hand-Controlled Particle System</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #050505;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    /* 3D Container */
    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    /* Hidden Video Element for MediaPipe */
    .input_video {
      display: none;
    }

    /* UI Overlay - Glassmorphism */
    #ui-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 280px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      z-index: 10;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease;
    }

    h2 {
      margin-top: 0;
      font-size: 1.2rem;
      font-weight: 500;
      margin-bottom: 15px;
      letter-spacing: 1px;
    }

    .control-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-size: 0.9rem;
      opacity: 0.8;
    }

    /* Modern Buttons */
    .btn-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    button {
      background: rgba(255, 255, 255, 0.15);
      border: none;
      padding: 10px;
      color: white;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
      font-size: 0.85rem;
    }

    button:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    button.active {
      background: rgba(0, 255, 179, 0.4);
      border: 1px solid rgba(0, 255, 179, 0.6);
    }

    /* Color Picker */
    input[type="color"] {
      width: 100%;
      height: 40px;
      border: none;
      border-radius: 8px;
      background: transparent;
      cursor: pointer;
    }

    /* Loading Spinner */
    #loader {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      z-index: 20;
      font-size: 1.5rem;
      text-align: center;
    }

    .status {
      font-size: 0.8rem;
      margin-top: 10px;
      color: #aaa;
    }

    #hand-status {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.5);
      z-index: 5;
      font-size: 0.9rem;
    }

  </style>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>

<body>

  <div id="loader">
    Initializing AI Vision...<br>
    <span style="font-size:0.9rem; opacity:0.7">Please allow camera access</span>
  </div>

  <div id="ui-panel">
    <h2>Particle Controller</h2>

    <div class="control-group">
      <label>Shape Template</label>
      <div class="btn-grid">
        <button onclick="changeShape('heart')" class="active" id="btn-heart">Heart</button>
        <button onclick="changeShape('flower')" id="btn-flower">Flower</button>
        <button onclick="changeShape('saturn')" id="btn-saturn">Saturn</button>
        <button onclick="changeShape('helix')" id="btn-helix">Helix</button>
        <button onclick="changeShape('sphere')" id="btn-sphere">Sphere</button>
        <button onclick="changeShape('galaxy')" id="btn-galaxy">Galaxy</button>
      </div>
    </div>

    <div class="control-group">
      <label>Particle Color</label>
      <div class="btn-grid" style="grid-template-columns: 70% 30%;">
        <input type="color" id="colorPicker" value="#00ffcc" style="height: 40px; padding: 0 5px;">
        <button onclick="toggleAutoColor()" id="btn-auto-color" style="padding: 10px 5px;">Auto</button>
      </div>
    </div>

    <div class="status">
      <p><strong>Gestures:</strong></p>
      <p>üëã Move hands apart to Scale Up</p>
      <p>‚úä Clench fists to Explode/Jitter</p>
    </div>
  </div>

  <div id="hand-status">Waiting for hands...</div>

  <div id="canvas-container"></div>
  <video class="input_video"></video>

  <script>
    // --- 1. CONFIGURATION & STATE ---
    const CONFIG = {
      particleCount: 15000,
      particleSize: 0.15,
      baseColor: 0x00ffcc,
      lerpSpeed: 0.08
    };

    let scene, camera, renderer, particles, geometry, material;
    let targetPositions = []; // The shape we want to form
    let currentShape = 'heart';

    let isAutoColorActive = false;
    let colorHue = 0;

    // Hand Interaction State
    let handInteraction = {
      scale: 1.0,
      explosion: 0.0, // 0 = stable, 1 = chaotic
      active: false
    };

    // --- 2. THREE.JS SETUP ---
    function initThree() {
      const container = document.getElementById('canvas-container');

      scene = new THREE.Scene();
      // Add subtle fog for depth
      scene.fog = new THREE.FogExp2(0x050505, 0.03);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 15;

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      // Generate Particles
      createParticleSystem();

      // Initial Shape
      calculateShape('heart');

      // Event Listeners
      window.addEventListener('resize', onWindowResize, false);
      document.getElementById('colorPicker').addEventListener('input', (e) => {
        material.color.set(e.target.value);
        // ÂΩìÁî®Êà∑ÈÄâÊã©È¢úËâ≤Êó∂ÔºåÁ¶ÅÁî®Ëá™Âä®ÂèòËâ≤
        if (isAutoColorActive) {
          isAutoColorActive = false;
          document.getElementById('btn-auto-color').classList.remove('active');
        }
      });

      animate();
    }

    function createParticleTexture() {
      // Create a soft glow dot texture using Canvas
      const canvas = document.createElement('canvas');
      canvas.width = 32;
      canvas.height = 32;
      const context = canvas.getContext('2d');
      const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
      gradient.addColorStop(0, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
      gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      context.fillStyle = gradient;
      context.fillRect(0, 0, 32, 32);

      const texture = new THREE.CanvasTexture(canvas);
      return texture;
    }

    function createParticleSystem() {
      geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(CONFIG.particleCount * 3);

      // Initialize random positions
      for (let i = 0; i < CONFIG.particleCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 50;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      material = new THREE.PointsMaterial({
        color: CONFIG.baseColor,
        size: CONFIG.particleSize,
        map: createParticleTexture(),
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);
    }

    // --- 3. SHAPE MATHEMATICS ---
    // Generates target coordinates for different shapes
    function calculateShape(type) {
      currentShape = type;
      targetPositions = new Float32Array(CONFIG.particleCount * 3);

      // Helper to get array index
      const setPos = (i, x, y, z) => {
        targetPositions[i * 3] = x;
        targetPositions[i * 3 + 1] = y;
        targetPositions[i * 3 + 2] = z;
      };

      for (let i = 0; i < CONFIG.particleCount; i++) {
        let x, y, z;
        const t = Math.random() * Math.PI * 2;
        const u = Math.random() * Math.PI * 2;
        const v = Math.random();

        if (type === 'heart') {
          // 3D Heart Formula
          // Reference: Complex parametric equations simplified
          let phi = Math.random() * Math.PI * 2;
          let theta = Math.random() * Math.PI;
          // A spread of points inside a heart volume
          // Simplification for visual effect:
          const r = Math.pow(Math.random(), 1 / 3) * 5; // Distribution
          // Basic Heart shape 2D extruded
          let hx = 16 * Math.pow(Math.sin(phi), 3);
          let hy = 13 * Math.cos(phi) - 5 * Math.cos(2 * phi) - 2 * Math.cos(3 * phi) - Math.cos(4 * phi);

          // Add volume Z
          x = hx * 0.3 * (1 + (Math.random() - 0.5) * 0.2);
          y = hy * 0.3 * (1 + (Math.random() - 0.5) * 0.2);
          z = (Math.random() - 0.5) * 4;
        }
        else if (type === 'sphere') {
          // Random point in sphere
          const theta = Math.random() * 2 * Math.PI;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = 6 * Math.pow(Math.random(), 1 / 3);
          x = r * Math.sin(phi) * Math.cos(theta);
          y = r * Math.sin(phi) * Math.sin(theta);
          z = r * Math.cos(phi);
        }
        else if (type === 'flower') {
          // Rose curve logic (polar to cartesian)
          const k = 4; // number of petals
          const rad = Math.cos(k * t) * 7;
          x = rad * Math.cos(t) + (Math.random() - 0.5);
          y = rad * Math.sin(t) + (Math.random() - 0.5);
          z = (Math.random() - 0.5) * 3;
        }
        else if (type === 'saturn') {
          if (i < CONFIG.particleCount * 0.7) {
            // Planet
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 4;
            x = r * Math.sin(phi) * Math.cos(theta);
            y = r * Math.sin(phi) * Math.sin(theta);
            z = r * Math.cos(phi);
          } else {
            // Ring
            const angle = Math.random() * Math.PI * 2;
            const radius = 6 + Math.random() * 4;
            x = Math.cos(angle) * radius;
            z = Math.sin(angle) * radius;
            y = (Math.random() - 0.5) * 0.5;
            // Tilt the ring
            const tempY = y;
            const tempZ = z;
            const tilt = 0.4;
            y = tempY * Math.cos(tilt) - tempZ * Math.sin(tilt);
            z = tempY * Math.sin(tilt) + tempZ * Math.cos(tilt);
          }
        }
        else if (type === 'helix') {
          // Double Helix
          const turns = 4;
          const height = 12;
          const radius = 3;
          const side = i % 2 === 0 ? 1 : -1;
          const p = (i / CONFIG.particleCount) * Math.PI * 2 * turns;
          x = Math.cos(p) * radius;
          z = Math.sin(p) * radius + (side * 3); // separation
          y = (i / CONFIG.particleCount) * height - (height / 2);

          // Add noise
          x += (Math.random() - 0.5);
          z += (Math.random() - 0.5);
        }
        else if (type === 'galaxy') {
          const coreRatio = 0.15; // 15% of particles in the core, more for arms
          const haloRatio = 0.5; // 5% of particles in the halo

          if (i < CONFIG.particleCount * coreRatio) {
            // --- 1. Central Core (dense sphere) ---
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 3 * Math.pow(Math.random(), 1.5); // Power makes it denser towards center
            x = r * Math.sin(phi) * Math.cos(theta);
            y = r * Math.sin(phi) * Math.sin(theta);
            z = r * Math.cos(phi);
          } else if (i < CONFIG.particleCount * (coreRatio + haloRatio)) {
            // --- 2. Halo (large, sparse sphere) ---
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 15 + Math.random() * 10; // Large radius
            x = r * Math.sin(phi) * Math.cos(theta);
            y = r * Math.sin(phi) * Math.sin(theta);
            z = r * Math.cos(phi);
          } else {
            // --- 3. Spiral Arms (Whirlpool Galaxy Style) ---
            const numArms = 5; // More arms for a denser look
            const arm = i % numArms;

            // This creates a tighter, more defined spiral
            const b = 0.4; // Spiral tightness factor
            const particleProgress = (i - CONFIG.particleCount * (coreRatio + haloRatio)) / (CONFIG.particleCount * (1 - coreRatio - haloRatio));
            const angle = particleProgress * Math.PI * 10; // More turns
            const radius = 2 * Math.exp(b * angle);

            // Base spiral position
            const armAngle = (arm / numArms) * Math.PI * 2;
            x = Math.cos(angle + armAngle) * radius;
            z = Math.sin(angle + armAngle) * radius;

            // Add very subtle randomness to give the arms some volume but keep them distinct
            x += (Math.random() - 0.5) * 1.0; // Increased thickness
            z += (Math.random() - 0.5) * 1.0; // Increased thickness

            // Add vertical spread (thickness of the galaxy disk)
            // Make the disk very flat for a classic spiral galaxy look
            y = (Math.random() - 0.5) * 0.5 * (1 - radius / 30);
          }
        }

        setPos(i, x, y, z);
      }
    }

    function changeShape(shape) {
      // UI Update
      document.querySelectorAll('.btn-grid button').forEach(b => b.classList.remove('active'));
      document.getElementById(`btn-${shape}`).classList.add('active');

      // Adjust camera for a better view of specific shapes
      if (shape === 'galaxy') {
        // Move camera to a top-down view to see the spiral
        camera.position.set(0, 20, 0); // Zoom in closer
        camera.lookAt(scene.position); // Explicitly look at the center
      } else {
        // Return to the default frontal view for other shapes
        camera.position.set(0, 0, 15);
        camera.lookAt(scene.position); // Ensure it looks at the center too
      }
      calculateShape(shape);
    }

    function toggleAutoColor() {
      isAutoColorActive = !isAutoColorActive;
      const btn = document.getElementById('btn-auto-color');
      btn.classList.toggle('active');
    }


    // --- 4. ANIMATION LOOP ---
    function animate() {
      requestAnimationFrame(animate);

      const positions = particles.geometry.attributes.position.array;

      // Time factor for idle animation
      const time = Date.now() * 0.001;

      // Ëá™Âä®È¢úËâ≤ÂèòÊç¢ÈÄªËæë
      if (isAutoColorActive) {
        colorHue = (colorHue + 0.001) % 1; // Â¢ûÂä†Ëâ≤Áõ∏ÂÄºÂπ∂Âæ™ÁéØ
        material.color.setHSL(colorHue, 1.0, 0.5); // ËÆæÁΩÆ HSL È¢úËâ≤ (Ëâ≤Áõ∏, È•±ÂíåÂ∫¶, ‰∫ÆÂ∫¶)
      }

      // Base Scale from Hands
      let targetScale = handInteraction.active ? handInteraction.scale : 1.0;
      // Smoothly interpolate current scale
      particles.scale.setScalar(THREE.MathUtils.lerp(particles.scale.x, targetScale, 0.1));

      // Rotation
      particles.rotation.y += 0.002;
      if (currentShape === 'saturn') particles.rotation.z = 0.2;
      else particles.rotation.z = 0;

      for (let i = 0; i < CONFIG.particleCount; i++) {
        const px = i * 3;
        const py = i * 3 + 1;
        const pz = i * 3 + 2;

        // 1. Get Target Position
        let tx = targetPositions[px];
        let ty = targetPositions[py];
        let tz = targetPositions[pz];

        // 2. Apply Fireworks / Explosion Jitter
        // If hand is clenched (explosion > 0), push particles outward randomly
        if (handInteraction.explosion > 0.1) {
          const explForce = handInteraction.explosion * 5;
          tx += (Math.random() - 0.5) * explForce * 10;
          ty += (Math.random() - 0.5) * explForce * 10;
          tz += (Math.random() - 0.5) * explForce * 10;
        }

        // 3. Morphing Logic (Lerp current pos to target pos)
        positions[px] = THREE.MathUtils.lerp(positions[px], tx, CONFIG.lerpSpeed);
        positions[py] = THREE.MathUtils.lerp(positions[py], ty, CONFIG.lerpSpeed);
        positions[pz] = THREE.MathUtils.lerp(positions[pz], tz, CONFIG.lerpSpeed);

        // 4. Idle Noise (Breathing effect)
        positions[px] += Math.sin(time + positions[py]) * 0.01;
        positions[py] += Math.cos(time + positions[px]) * 0.01;
      }

      particles.geometry.attributes.position.needsUpdate = true;
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- 5. MEDIAPIPE HAND TRACKING ---
    function initMediaPipe() {
      const videoElement = document.getElementsByClassName('input_video')[0];

      const hands = new Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }
      });

      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      hands.onResults(onHandsResults);

      const cameraFeed = new Camera(videoElement, {
        onFrame: async () => {
          await hands.send({ image: videoElement });
        },
        width: 640,
        height: 480
      });

      cameraFeed.start()
        .then(() => {
          document.getElementById('loader').style.display = 'none';
          document.getElementById('hand-status').innerText = 'Camera Active. Show hands.';
        })
        .catch(err => {
          document.getElementById('loader').innerText = 'Camera Error: ' + err;
        });
    }

    function onHandsResults(results) {
      const handStatus = document.getElementById('hand-status');

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        handInteraction.active = true;

        // Logic for 2 Hands
        if (results.multiHandLandmarks.length === 2) {
          const hand1 = results.multiHandLandmarks[0];
          const hand2 = results.multiHandLandmarks[1];

          // 1. Calculate Distance between hands (Wrist to Wrist) for SCALE
          // wrist is landmark 0
          const dist = Math.sqrt(
            Math.pow(hand1[0].x - hand2[0].x, 2) +
            Math.pow(hand1[0].y - hand2[0].y, 2)
          );

          // Map distance (approx 0.1 to 0.8) to scale (0.5 to 3.0)
          const mappedScale = Math.max(0.2, Math.min(3.0, dist * 4));
          handInteraction.scale = mappedScale;

          handStatus.innerText = `Dual Hands: Scaling (${mappedScale.toFixed(1)}x)`;
        } else {
          // Single Hand Logic
          handStatus.innerText = "Single Hand Detected";
          handInteraction.scale = 1.0;
        }

        // 2. Calculate "Fist" gesture for EXPLOSION
        // We check average distance of fingertips (8, 12, 16, 20) to wrist (0)
        let totalOpenness = 0;
        results.multiHandLandmarks.forEach(hand => {
          const wrist = hand[0];
          const tips = [8, 12, 16, 20]; // Index, Middle, Ring, Pinky tips
          let fingerDist = 0;
          tips.forEach(idx => {
            const tip = hand[idx];
            fingerDist += Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
          });
          totalOpenness += fingerDist; // Higher = Open Hand, Lower = Fist
        });

        // Normalize openness. 
        // 1 hand ~ 1.5 total dist is open, ~0.5 is closed
        // 2 hands ~ 3.0 is open, ~1.0 is closed
        const threshold = results.multiHandLandmarks.length * 0.8;

        if (totalOpenness < threshold) {
          // FIST DETECTED -> Explode
          handInteraction.explosion = THREE.MathUtils.lerp(handInteraction.explosion, 1.0, 0.1);
          handStatus.innerText += " | ‚úä Fist (Explode)";
        } else {
          // OPEN HAND -> Stable
          handInteraction.explosion = THREE.MathUtils.lerp(handInteraction.explosion, 0.0, 0.1);
        }

      } else {
        handInteraction.active = false;
        handInteraction.explosion = 0;
        handStatus.innerText = "No hands detected";
      }
    }

    // Initialize Everything
    initThree();
    initMediaPipe();

  </script>
</body>

</html>
